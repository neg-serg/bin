#!/usr/bin/env python3

""" nwim runner

 _ ____      _(_)_ __ ___
| '_ \ \ /\ / / | '_ ` _ \
| | | \ V  V /| | | | | | |
|_| |_|\_/\_/ |_|_| |_| |_|

Usage:
  nwim.py

Options:
  -h --help     Show this screen.
  --version     Show version.

Created by :: Neg
email :: <serg.zorg@gmail.com>
github :: https://github.com/neg-serg?tab=repositories
year :: 2018

"""

from psutil import net_connections
import subprocess
import time
import os.path
import re
import shlex  # shell string to list
from pathlib import Path  # get corrent path
import sys  # options
from colored import fg  # colors


class pretty_printer(object):
    def __init__(self):
        self.darkblue = fg(4)
        self.darkwhite = fg(7)
        self.darkgray = fg(237)
        self.cyberblue = fg(200)
        self.default = fg(0)

    # generic string wrapper
    def wrap(self, str):
        return self.darkblue + "⟬" + self.darkwhite + str + self.darkblue + "⟭"

    def size(self, sz):
        return self.wrap(
            self.darkwhite + "sz" + self.darkgray + "~" +
            self.darkwhite + str(sz)
        )

    def filelen(self, len):
        return self.wrap(
            self.darkwhite + "len" + self.darkgray + "=" +
            self.darkwhite + str(len)
        )

    def newfile(self, filename):
        return self.wrap(filename)

    def dir(self, filename):
        return self.wrap(filename)

    def prefix(self):
        return self.wrap(fg(25) + ">" + fg(26) + ">")

    def delim(self):
        return (self.cyberblue + self.default)

    # pretty printing for filename
    def fancy_file(self, filename):
        filename = re.sub(os.environ["HOME"], fg(2) + "~" + fg(7), filename)
        filename = re.sub("/", fg(4) + "/" + fg(7), filename)
        return self.wrap(filename)


# file info printer
class file_info_printer(object):
    def __init__(self):
        self.printer = pretty_printer()

    # counting with external wc is faster than everything else
    def wccount(self, filename):
        out = subprocess.Popen(
            ['wc', '-l', filename],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL
        ).communicate()[0]

        return int(out.partition(b' ')[0])

    def nonexistsfile(self, filename):
        print(
            self.printer.prefix() +
            self.printer.fancy_file(filename) +
            self.printer.delim() +
            self.printer.newfile(filename)
        )

    def existsfile(self, filename):
        print(
            self.printer.prefix() +
            self.printer.fancy_file(filename) +
            self.printer.delim() +
            self.printer.size(os.stat(filename).st_size) +
            self.printer.delim() +
            self.printer.filelen(self.wccount(filename))
        )

    def currentdir(self, filename):
        print(
            self.printer.prefix() +
            self.printer.wrap("current dir") +
            self.printer.delim() +
            self.printer.dir(filename)
        )

    def dir(self, filename):
        print(
            self.printer.prefix() +
            self.printer.fancy_file(filename) +
            self.printer.delim() +
            self.printer.dir(filename)
        )


class wim_runner(object):
    def __init__(self):
        self.settings = {
            "debug": False,
        }

        self.font = "Iosevka Term Medium"
        self.fsize = 20

        self.unix_connections = net_connections(kind='unix')
        self.sock_path = os.path.realpath(
            os.path.expandvars("$HOME/1st_level/nvim.socket")
        )
        self.tmux_sock_path = os.path.realpath(
            os.path.expandvars("$HOME/1st_level/tmux_nvim.socket")
        )

        self.args = sys.argv

        if Path(self.sock_path).exists() and \
            (
                list(
                    filter(
                        lambda i: i.laddr == self.sock_path,
                        self.unix_connections
                        )
                    ) == []
                ):
            os.remove(self.sock_path)

        os.environ["NVIM_LISTEN_ADDRESS"] = self.sock_path

        self.vim_commands = {
            "to_normal": "<C-\\><C-N>:call<SPACE>foreground()<CR>",
            "dir": "-c 'doautocmd BufEnter'",
            "rsend": " --remote-send ",
            "rwait": " --remote-tab-wait ",
        }

        self.default_cmd = self.vim_commands["rsend"]

        self.timeout = .5
        self.cmd = ""
        self.wim_name = "nwim"
        self.printer = file_info_printer()

        self.nvr_env = os.environ.copy()
        self.nvr_env["NVIM_LISTEN_ADDRESS"] = self.sock_path

    def dprint(self, debug_string):
        if self.settings["debug"]:
            print(debug_string)

    def dprint_with_args(self, debug_string):
        def print_args(args):
            self.dprint("[::] Printing args [::]")
            for arg in args:
                self.dprint("{ " + arg + " }")

        self.dprint("[ " + debug_string + " ]")
        print_args(self.args)

    def tmux_socket_is_in_use_(self):
        return bool(list(
            filter(lambda i: i.laddr ==
                   self.tmux_sock_path, self.unix_connections)) != [])

    def no_wim_x11_win(self):
        nwim_win = subprocess.Popen(
            "wmctrl -xl|awk '{print $3}'|rg nwim",
            stdin=None,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
        )
        our, err = nwim_win.communicate()
        return "nwim.nwim" != our.decode().strip('\n')

    # goto neovim window
    def wim_goto(self):
        def there_is(wm_):
            if "DISPLAY" not in os.environ:
                return False
            else:
                pipe = subprocess.Popen(
                    'pidof {}'.format(wm_).split(), stdout=subprocess.PIPE
                )
                pid, _ = pipe.communicate()
                return pid != b''

        if there_is("i3"):
            self.dprint("[i3] :: go to win with it")
            subprocess.Popen(
                ["i3-msg", '[instance={}]'.format(self.wim_name), "focus"],
                stdout=open(os.devnull, 'w'),
                stderr=open(os.devnull, 'w')
            )

    # check wim started or not by internal variable in nvim
    def wim_is_started(self):
        ret = subprocess.Popen(
            shlex.split(
                """ nvr --remote-expr "printf(\\"%s\\", g:nvim_is_started)" """
            ),
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            env=self.nvr_env
        ).communicate()[0].decode("utf-8").strip('\n')
        self.dprint("nwim_started=[{}]".format(ret))
        return ret == "on"

    # wait for run
    def wait_for_run(self):
        while not len(self.nwim_wid()):
            self.dprint("wait st from scratch run")
            time.sleep(self.timeout)
        while not self.wim_is_started():
            self.dprint("wait for nvim")
            time.sleep(self.timeout)

    # it is the main function in the past, not sure for now
    def V(self):
        self.dprint_with_args("Run V")
        del self.args[0]

        self.wait_for_run()

        self.dprint("wim is started")
        self.wim_run()
        self.wim_goto()

    # It seems that only bash quoting works correctly
    # Probably this stuff should be replaced with encodef and friends
    def quotestr(self, string):
        quoted_string = subprocess.Popen(
            shlex.split("bash -c \"printf %q '" + string + "'\""),
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL
        ).communicate()[0].decode("utf-8").strip('\n')
        return quoted_string

    # Open file in daemon and print nice file info
    # Main function with several closures
    def vim_file_open(self, line, edit_file=True):
        def remote_edit_file(filename, file):
            # helper for remote_send
            def remote_edit_file_():
                self.dprint("[remote edit file]")
                ret = subprocess.Popen(
                    shlex.split(
                        "nvr " + prefix_cmd + self.default_cmd +
                        "\"" +
                        self.vim_commands["to_normal"] +
                        ":silent edit " +
                        self.quotestr(filename) +
                        "<CR>" +
                        self.cmd +
                        "\""
                    ),
                    stdout=subprocess.PIPE,
                    stderr=subprocess.DEVNULL,
                    env=self.nvr_env
                )
                return ret

            prefix_cmd = ""
            if file.is_dir():
                prefix_cmd += self.vim_commands["dir"]

            self.dprint("[remote send]")
            if remote_edit_file_().returncode != 0:
                remote_edit_file_()

        try:
            filename = os.path.normpath(os.path.realpath(line))
            file = Path(filename)  # normalize path
            if edit_file:
                # Open target file / dir
                remote_edit_file(filename, file)

            if not file.exists():
                self.printer.nonexistsfile(filename)
            elif file.is_file() and not file.is_dir():
                self.printer.existsfile(filename)
            elif file.is_dir():
                if filename == os.getcwd():
                    self.printer.currentdir(filename)
                else:
                    self.printer.dir(filename)
        except Exception:
            pass

    def process_list(self):
        self.wim_goto()

        self.cmd = self.vim_commands["to_normal"]

        if self.cmd == self.vim_commands["to_normal"]:
            for line in self.args:
                self.vim_file_open(line)
        else:
            subprocess.Popen(
                shlex.split("nvr " + self.default_cmd + self.cmd),
                stdout=subprocess.PIPE,
                env=self.nvr_env
            )

            for line in self.args:
                self.vim_file_open(line)

    def eprocess_list(self):
        for line in self.args:
            self.cmd = "nvr " + self.default_cmd + line
            subprocess.call(shlex.split(self.cmd))

    def wim_run(self):
        if self.mode == "default":
            proc = self.process_list
        elif self.mode == "embedded":
            self.default_cmd = self.vim_commands["rwait"]
            proc = self.eprocess_list

        if len(self.args):
            proc()

    def attach_term_to_tmux_if_needed(self):
        if self.tmux_socket_is_in_use_() and self.no_wim_x11_win():
            # do not wait for call result
            # x11 window is closed, but tmux connection exists
            subprocess.Popen([
                "st",
                "-f", "{}:pixelsize={}".format(self.font, self.fsize),
                "-c", "{}".format(self.wim_name),
                "-e", "tmux", "-S", self.tmux_sock_path,
                "attach-session", "-d", "-t", "nvim"
            ])

    def nwim_wid(self):
        return subprocess.Popen(
            'xdotool search --classname {}'.format(self.wim_name).split(),
            stdout=subprocess.PIPE, stderr=subprocess.PIPE
        ).communicate()[0].decode("utf-8").strip('\n')

    def create_nvim_server_if_needed(self):
        subprocess.Popen(
            shlex.split("st " + "-f '{}:pixelsize={}' "
                        .format(self.font, self.fsize) +
                        "-c " + self.wim_name +
                        " -e sh -c \"tmux -S " +
                        self.tmux_sock_path +
                        " new -s nvim -n nvim nvim\""
                        ), stdout=subprocess.PIPE)

        while not len(self.nwim_wid()):
            self.dprint("wait st from scratch run")
            time.sleep(self.timeout)

    def nvr_for_oni(self):
        subprocess.run(
            ["nvr", "--remote-silent"] + sys.argv[1:],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            env=run.nvr_env
        )

        for line in sys.argv[1:]:
            self.vim_file_open(line, edit_file=False)

    def switch_to_oni_window(self):
        subprocess.Popen(
            [
               os.environ["XDG_CONFIG_HOME"] + "/i3/send",
               "circle", "next", "nwim"
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
        )

    def spawn_oni(self):
        subprocess.Popen(
            ["i3-msg", "exec", "oni"],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL
        )

    def wait_for_oni(self):
        t = subprocess.check_output(['pgrep', 'oni$']) \
                      .decode('UTF-8').strip('\n')
        while not len(t):
            t = subprocess.check_output(['pgrep', 'oni$']) \
                          .decode('UTF-8').strip('\n')
            time.sleep(self.timeout)

    def wait_for_nvr(self):
        counter = 0
        nvim_server_is_here = subprocess.Popen(
            ['nvr', '--serverlist'],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL
        ).communicate()[0].decode('UTF-8').strip('\n')

        while not len(nvim_server_is_here):
            nvim_server_is_here = subprocess.Popen(
                ['nvr', '--serverlist'],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL
            ).communicate()[0].decode('UTF-8').strip('\n')
            time.sleep(self.timeout)
            counter += 1
            if counter > 9:
                return False
        return True

    def main(self, mode="default"):
        self.mode = mode

        if not self.tmux_socket_is_in_use_():
            self.create_nvim_server_if_needed()
        self.attach_term_to_tmux_if_needed()

        self.V()


if __name__ == '__main__':
    run = wim_runner()
    tmux_nvim = False

    oni_is_here = subprocess.Popen(
        ['pgrep', 'oni$'],
        stdout=subprocess.PIPE,
        stderr=subprocess.DEVNULL
    ).communicate()[0].decode('UTF-8').strip('\n')

    if not oni_is_here:
        run.spawn_oni()
        run.wait_for_oni()

    if run.wait_for_nvr():
        run.nvr_for_oni()
        run.switch_to_oni_window()
        sys.exit(0)

    if tmux_nvim:
        if os.environ.get("NWIM_STANDALONE"):
            run.main("embedded")
        else:
            run.main()

